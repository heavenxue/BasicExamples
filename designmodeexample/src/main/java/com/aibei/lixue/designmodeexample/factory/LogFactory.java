package com.aibei.lixue.designmodeexample.factory;

/**
 * 抽象工厂模式
 * 不需要指定他们具体的类，提供一系列相关或相互依赖对象的接口
 *
 * 作者：lixue on 2017/3/6 16:24
 *
 * 优点：
 * *抽象工厂模式隔离了具体类的生成。抽象工厂模式可以实现搞内聚低耦合的设计目的，因此这种模式得到了广泛应用
 * *增加新的工厂和产品族很方便，无需修改已有系统，符合“开闭原则”
 *
 * 缺点：
 * * 在添加新的产品对象时，难以扩展抽象工厂来生产新的产品类，这是因为抽象工厂角色中规定了所有可能被创建的产品集合
 * 要支持新的产品类，意味着要对该工厂的接口类进行扩展，而这将涉及到抽象工厂角色以及所有子类的修改，显然会带来很大麻烦
 * *开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）
 *
 * 适用环境
 * ~一个系统不应当依赖产品类实例如何创建、组合和表达的细节，对于所有工厂模式都适用
 * ~系统中有多个产品族，而每次只使用某一个产品族
 * ~属于同一产品族中的产品在一起使用，这一约束必须在系统的设计中体现出来
 * ~系统提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现
 *
 * 模式应用
 * 在很多软件系统中需要更换界面主题，要求界面中的按钮、文本框、背景色等一起发生改变时，可以使用抽象工厂模式进行设计。
 *
 * 工厂模式的退化
 * 当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；
 * 当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。
 *
 *   工厂方法模式只有一个抽象产品类，而抽象方法模式有多个
 *   工厂方法模式只能创建一个产品的实例，而抽象方法能创建多个
 */

public class LogFactory implements ILogFactory {
    @Override
    public ILog createFileLog() {
        return new FileLog();
    }

    @Override
    public ILog2 createDatabaseLog() {
        return new DataBaseLog();
    }
}
